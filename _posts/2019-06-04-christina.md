6/4/19
================

<p class="meta">4 June 2019</p>

I am very satisfied with my work today. I was able to execute my plan from yesterday to built an automatic unsubscription feature. Unfortunately, it took the entire day because of some setbacks I faced with my strategy and its general difficulty to test (filling out a form, executing code, manually checking for errors, resetting), but I am pleased nonetheless. I was disappointed, however, because my partner really did not contribute much. I am beginning to think I am overbearing, and should really take a step back, however I find the group dynamic difficult especially when we have such different work styles. He likes to plan and take his time, while I prefer to just start writing code, and learning as I go. I start with my initial idea and familiarize myself with the process by just learning by doing. When it works, my methods are generally faster, so I feel like I prevent my partner from making meaningful contributions. However, I will say that I spend more time on task, though everyone works differently.

Stepping out of this interpersonal realm, though: my code works! At the end of the day, I feel as if this matters the most... The code started with getting the data from the sheet in which the unsubscription requests were processed. Even this presented its own challenges, because it required unique numbering of rows and columns. It also required switching between characters and number to reference columns. On top of all of this, Google Sheets does not count ordinally, so keeping track of how I had to shift my numbers was difficult. I figured out a very effective means of switching between column characters and numbers, though, using the built-in function ‘String.fromCharCode’. Like ‘ord’ and ‘char’ in Python, I was able to use the number value of my column to create the character code for the ASCII character I needed to represent that column. For example, “3” became “C” and “1” became “A”.

After getting the data definition out of the way, I checked if there was unprocessed data. Using my definition from yesterday’s strategy, “unprocessed” would refer to rows that had an empty status logging column, meaning that they had not yet been removed from the main spreadsheet. These rows then became the data I was actually interested in. From these rows, there were just two entries from users that I cared about: form of contact, and contact info. I had provided a way to offer feedback, but that wasn’t useful to me computationally. With the form of contact row, that told me whether to look in the email or text column on the mainsheet for the contact info provided. I handled this with a simple if-statement. Because the form uses drop-down menus, I did not need to account for errors upon entry of “E-mail” or “Text”. With this, I used a helped function to find the row at which the contact info occured in the main sheet, creating a list. This list represented all of the rows that needed to be deleted. Initially, I just ran this function as-is, but this proved problematic. This was because ros would renumber themselves each time a row was deleted, leading to incorrect rows getting deleted. I was unsure of how to handle this, first approaching it with a brute force method of adjusting the values in this row removal list each time a row was removed. This was complex, clunky, and also ineffective. This is because the numbers are not reordered whenever a row below a value is deleted. Taking this into account seemed very, very hard, so I decided to change my approach altogether. Instead of iterating through the list from zero upwards, I decided to go backwards, hoping to take advantage of  the way in which numbers are reordered based solely on the deletion of rows ABOVE them. I thought I could avoid this by going backwards. This turned out not to be wrong, but not to be quite right either. Once I reordered my list sequentially using a built-in ‘sort’ function and counted down, this worked perfectly. This meant that there was never row deleted above another row primed for deletion, leading to no renumbering. Thinking back on it, this seemed like a more obvious solution than it was.

After all of that, the function worked! I was able to then place it in a try-catch statement, not running the function if there was no new data (a.k.a, the last row had a full status column). A browser dialog would pop up at this point and, once closed, the function would end. I was very pleased with all of this work, and it was satisfying to watch the rows get deleted and logged exactly how I had intended. Tomorrow, I am excited to present this, among other features to Nicole at the Green Crew in our first follow-up meeting. I hope she likes what we have done, and we get some new tasks to work on. 
