5/30/19
================

<p class="meta">30 May 2019</p>

Today was another very productive day. We approached our most difficult problem yet, and one of our most most important: integrating multiple zip codes. Before today, the program was only applicable to one zip code, globally defined before intense computation begun. However, this really limited the scope of the program, as it could only be so geographically large and still retain its accuracy. We had already decided to collect zip code from user’s when they sign up, however, we didn’t have a good plan for implementing it. This morning, we sat down and traced out the intricacies of trying to run our program for more than one zip code. The reason that this is so hard is that we have to make calls the our weather API for each zip code. This, computationally, is expensive, taking a lot of time and power especially when many requests are consecutively made to an API. Knowing this, we set out with a goal to minimize the number of API calls we made: just one for each unique zip code. We did something very similar yesterday with calling the Google Translate API, so we used the same method. This turned out to be the easy part, and we struggled tracing this data’s path throughout our current program. It ended up being the most helpful to physically draw a flow chart of how our program worked. We could break it down into two steps: the defining of our data, and then its subsequent processing.

After struggling for most of the morning, Prof Medero helped refine our strategy, allowing us to only make one dictionary when we had originally intended on making 2 or 3. Instead of redoing computation, we did everything at the front end: getting weather data, parsing it, and getting the related watering frequency, before going on to define the body of our message and sending it.  This ended up being fairly intuitive. We could keep our definition of the dictionary for the most part, however, we needed to pass the original parsed data into each of the functions used to parse the data. This was not difficult, though we needed to be methodical as not to miss any instances where the function was called. After this, we tested our work, and much to our surprise, everything ran perfectly on the first try! Now we had a program that can send messages in 20 different languages, to a variety zip codes, and considers weather conditions in addition to temperature. 

For the rest of afternoon, I worked further on generalizing code that had already been written. With the ability to send notifications to those in different zip code, I wondered how far our code could be expanded in the very literal sense. I looked up the capabilities of both outside service we are using: OWM and Twilio, and saw both had international capabilities. Because of this, I knew that, with a few changes, our code could have an even wider scope: the whole globe, in fact. To allow for this international capability, I added global variables for country postal codes as well as units in which weather is displayed. This allows for the weather API to retrieve weather for anywhere in the world in Fahrenheit, Celcius, or Kelvin. The only caveat with this, is that because these variables are global, I am assuming that whoever implements this program will only be looking at one country. For our project, I think this is reasonable, but support for multiple countries could likely be implemented in a similar fashion to the multiple zip code support. 

Tomorrow, I hope to finish up adding international support by addressing the formatting of phone numbers which can vary in length from country to country. There is an international standard that Twilio requires, however, and I will need to look further into that before implementing ay code. Besides that, our next big project is to implement reminders for different times of day as preferred by users. I will need clarification on how to do this because I don’t currently know if this is something to be handled within the code itself, or with the triggers used by Google App Scripts.
