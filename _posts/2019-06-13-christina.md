6/13/19
================

<p class="meta">13 June 2019</p>

I should not have been surprised by what turned into a wildy frustrating day. I have found it very tiring this week to be introduced to the code form the group last year, and retracing their steps as to understand what was written. Behind just comprehending what was written, I had to familiarize myself with both iTree and xml, and the processes used for linking the two. It has not helped that much of the code was messy, used irregular syntax, and lacked a good method to check accuracy. 

I spent the large majority of my time today working on simplifying the code used to calculate overall project benefits, reducing its 19 function calls within the main export function down to, hopefully, just one. I struggled a lot with this process because of the logical difficulties when dealing with the equivalent of three for-loops. These “loops” scan through each attribute, each tree, and each node within each tree. Ideally, I would like to find all of the nodes for every tree and every attribute before beginning to process the data. This process of node-gathering calls a helper function, so by doing this I would reduce calls to the helper function, as well. In its current state, it's almost absurd how many functions are uniquely called in processing this data, and I am somewhat comically reassured that however I change it will be a reduction, because with 38 function calls, there’s practically nowhere to go but down. 

My first attempt at this problem made the code much more elegant, however, it did not achieve the increases in speed that I had hoped. I decided to alter the helper function in order to only have to run it once, thinking this would improve runtime. I did this by placing the majority of the function within a for-loop, and calling it for each entry in a list of string representations of the parameters required by iTree. Instead of a one-dimensional list, the function would now output a two-dimensional array. I could then implement this list in one function call (1 << 38!!) within the larger export function, simply pulling data from different indexes based on the attributes that were needed. This did make the function much more complicated, and when tested, the values produced were very different than expected. Unfortunately, “different that expected” doesn’t mean “explicitly wrong” because we were unsure that our previous values for the data was correct. Additionally, we lack the background to be able to determine reasonability when it came to the numbers that we got. Without this, it was hard to be sure that the function worked, even if it returned values, and did not run into any errors.  I did have some clues that it was incorrect, though. It differed greatly from Vivian’s answers from her work on calculating individual tree benefits, though we were also unsure of that work’s accuracy. Reymon was not helping us with this, and was focused on researching Google MyMaps. Again, his lack of productivity frustrates me...

Even with the uncertainties of the results of my function, I had other reasons to doubt my work. By making the majority of the computation run within a for-loop, I was doing just as much work as the function would have otherwise, but it was disguised by the singular function call. I was still calling another function 19 times (the number of different attributes within iTree) and retrieving and searching the same xml multiple times for different things. A bit defeated, I began to reevaluate my strategy. I identified the bottleneck pretty quickly: searching the xml. So, now: how could I reduce the time it takes? Easy. Only search the xml once for all of the information that I want. The current code only allows for the xml to be searched for one node name, so I began to write a program that would search the xml for each root name in my list of iTree parameters. Writing this, I’m sort of kicking myself because I fell into the same trap here as I did earlier; I may have made the code more elegant, but I did not actually reduce the computation required at all. At the time, though, I did not realize this, and proceeded to write a function to create a three-dimensional list to keep track of nodes with their accompanying years, years with their accompanying trees, and years with the total benefit per attribute based on the sum of the benefits for all of the trees. Needless to say, this became a very complex list. I worked straight through the day on the logic of this, but it still has proven too difficult for me to finish, I even ended up working through lunch on it It’s also not beneficial to have one of my partners off task while I am struggling so much.

Towards the end of the day, I ended up realizing my naiveté in my problem solving strategy, and reapproached the whole task. The bottleneck was within searching the xml, so why don’t I change how the xml is searched? I’m not sure how to proceed with this, but I’m envisioning an input of a list of node names to search for, and an organized list returned, even possibly a dictionary to make organization a bit easier on myself. I’ll see how this goes tomorrow…
